

* Resources

 - https://www.nasm.us/doc/
 - https://pacman128.github.io/pcasm/
 - https://cs.lmu.edu/~ray/notes/nasmtutorial/
 - https://www.codecademy.com/learn/computer-architecture-assembly-language
 - https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/resources/intro-to-assembly-language-8-13-/
 - https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file (zerg)
 - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

 
* General 

 - X86 registers

| 64-bit | 32-bit | 16-bit | 8 high bits | 8 low bits | Description        |
|--------+--------+--------+-------------+------------+--------------------|
| RAX    | EAX    | AX     | AH          | AL         | Accumulator        |
| RBX    | EBX    | BX     | BH          | BL         | Base               |
| RCX    | ECX    | CX     | CH          | CL         | Counter            |
| RDX    | EDX    | DX     | DH          | DL         | Data               |
| RSI    | ESI    | SI     | N/A         | SIL        | Source             |
| RDI    | EDI    | DI     | N/A         | DIL        | Destination        |
| RSP    | ESP    | SP     | N/A         | SPL        | Stack Pointer      |
| RBP    | EBP    | BP     | N/A         | BPL        | Stack Base Pointer |


* https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file

 - https://www.cs.drexel.edu/~bls96/museum/cardiac.html

 - https://en.wikipedia.org/wiki/Signedness

#+begin_quote
In computing, signedness is a property of data types representing numbers in computer programs.

A numeric variable is *signed*:
 - if it can represent both *positive and negative* numbers,

And *unsigned*:
 - if it can only represent non-negative numbers (*zero or positive numbers*).
#+end_quote   

 
** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bits-bytes-words-and-number-bases][Bits, Bytes, Words, and Number Bases]]

 | Bit | Byte                     | Word                         | Number Base       |
 |-----+--------------------------+------------------------------+-------------------|
 | 0/1 | 8bits                    | 2 bytes grouped (16 bits)    | binary            |
 |     | 76543210                 | 5432109876543210             | base 2            |
 |     | unsigned value 0-255     | bit 15 "High order sign bit" | add a lead 0      |
 |     | signed value of -128/127 |                              | and terminating b |
 |     | Bit 7 the "sign bit":    |                              | 011111111b        |
 |     | - 1: negative            |                              | ----------------- |
 |     | - 2: positve             |                              | hexadecimal       |
 |     |                          |                              | nybble:           |
 |     |                          |                              | - 4 bits (0-15)   |
 |     |                          |                              |                   |


unsigned value ranges for common word sizes

#+begin_quote
1 bit:  0-1
2 bits: 0-3
3 bits: 0-7
4 bits: 0-15
5 bits, 0-31
...
#+end_quote

The pattern here is that the max value is 2 to the number of bits minus 1.
That is for 5 bits, the max value 31 is 2 to the 5th power (32) minus 1.

When we convert a binary byte to hex, we visualize it something like this:

#+begin_quote
76543210 is 7654 3210
#+end_quote

We've grouped the bits as two nybbles.
We can then convert the two nybbles (4 bits each) to two hex digits.

| Binary | Hex |
|--------+-----|
|   0000 |   0 |
|   0001 |   1 |
|   0010 |   2 |
|   0011 |   3 |
|   0100 |   4 |
|   0101 |   5 |
|   0110 |   6 |
|   0111 |   7 |
|   1000 |   8 |
|   1001 |   9 |
|   1010 |   A |
|   1011 |   B |
|   1100 |   C |
|   1101 |   D |
|   1110 |   E |
|   1111 |   F |


For example, we visualize the binary value 010100101b as 1010 0101.
Using the table above, we see 1010 is A, and 0101 is 5. So the byte value is A5.
We represent hex numbers in assembly as 0xa5, or 0a5h, or sometimes $a5.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#math][Math]]

Adding two values of the same word size:
 The byte 100 plus the byte 50 = 150. 100 + 50 = 150.

This works for signed and unsigned values.
The math is always unsigned, but the result is up to you.
If the high order bit (bit 7 of a byte, bit 15 of a 16-bit word...) is 1, the signed value is negative.

What happens when we add a byte value to a 16-bit word value?
 - The byte value is really a 16-bit value, but the upper 8 bits are zeros.
 - That is, 0xaa can be visualized as 0x00aa. We just add the full 16-bit values together.

What happens when we add 1 to a byte size value of 255?
We only have 8 bits for the result, but we have 9 bits of actual value.
That is, 255 + 1 is 256.
Represented in binary, you have 255 = 011111111b + 1 = 0100000000b (9 bits!).
The 9th bit is basically ignored as far as the result byte goes.
So if you look at the lower 8 bits of our 9 bit result, we get 0!

All this extends to 32 bit and 64 bit words.

Multiplication of two values requires a double-sized result,
or you lose a lot more than just the 9th bit.

Consider 255 x 255 = 65025 (0xfe01), which fits in 16 bits but not in 8.
If we have a byte result, we get 0x01 due to the overflow, losing over 65000 in result value.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#boolean-algebra][Boolean Algebra]]

Single value operands, 4 combinations possible (truth table):

#+begin_src
AND (if both operands are true, the result is true)
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

OR (if either operand is true, the result is true)
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

XOR (if only one operand is true, the result is true)
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
#+end_src

The ~ (1's complement) operator inverts the bits in the word.

#+begin_src asm
00000000 & 00000000 = 0
00000000 & 00000001 = 0
...
#+end_src

BUT, we have 8 bits, so the operation is performed on all 8 bits in the two operands.

#+begin_src asm
   10000000 
OR 00000001 
   --------
   ^      ^
=  10000001
   ^      ^
   
NOT 10000001
=   01111110
#+end_src

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bit-shifting][Bit Shifting]]

shift a bit to the left (<< operator in C) 1-7 bits:

#+begin_src asm 
001111101b << 1 = 011111010b

 001111101b  shifted left becomes
 ////////
x011111010b  (bit 0 becomes 0, bit 1 becomes 1, bit 2 becomes 0)
#+end_src

Note that we have the overflow problem here, as we did with addition. We have an upper bit that ends up in the "bit bucket" (thrown away).

A *left shift* of *1 bit is effectively a multiplication by 2*.
Consider 001b<<1 is 010b, or 2.
A left shift of *2 bits is a multiply by 4*, and so on.

Shifting to the right , but we now end up with the high bit being cleared and the low bit in the bit bucket.
A *right shift* of *1 bit is effectively a divide by 2*.
But this right shift will take a negative number and make it positive because the sign bit is cleared. 

So we need a second kind of right shift (*arithmetic shift right*)
for signed values that sets the high bit in the result to the high bit in the initial value.
















* ray nasmtutorial

https://cs.lmu.edu/~ray/notes/nasmtutorial/

#+begin_src asm  
	global _start

	section .text
_start: mov     rax, 1       ; sys call for write
	mov     rdi, 1       ; file handle 1 is stdout
	mov     rsi, message ; address of string to output
	mov     rdx, 13      ; number of bytes
	syscall              ; invoke os to d the write
        mov     rax, 60      ; sys call for exit
	xor     rdi, rdi     ; exit code 0
        syscall
	section .data
 message: db    "Hello, world", 10 ; note the newline at the end
#+end_src

A typical use of the AND operator is to clear bits in a value. If we AND with a value that is the inverse of a power of 2, we are simply clearing a bit. n AND !4 clears bit 3 in n.



#+begin_src sh  :eval no 
nasm -fmacho64 hello.asm && ld hello.o && ./a.out
#+end_src







