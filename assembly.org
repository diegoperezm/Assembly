

* Resources

 - https://www.nasm.us/doc/
 - https://pacman128.github.io/pcasm/
 - https://cs.lmu.edu/~ray/notes/nasmtutorial/
 - https://www.codecademy.com/learn/computer-architecture-assembly-language
 - https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/resources/intro-to-assembly-language-8-13-/
 - https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file (zerg)
 - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

 
* General 

 - X86 registers

| 64-bit | 32-bit | 16-bit | 8 high bits | 8 low bits | Description        |
|--------+--------+--------+-------------+------------+--------------------|
| RAX    | EAX    | AX     | AH          | AL         | Accumulator        |
| RBX    | EBX    | BX     | BH          | BL         | Base               |
| RCX    | ECX    | CX     | CH          | CL         | Counter            |
| RDX    | EDX    | DX     | DH          | DL         | Data               |
| RSI    | ESI    | SI     | N/A         | SIL        | Source             |
| RDI    | EDI    | DI     | N/A         | DIL        | Destination        |
| RSP    | ESP    | SP     | N/A         | SPL        | Stack Pointer      |
| RBP    | EBP    | BP     | N/A         | BPL        | Stack Base Pointer |


* https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file

 - https://www.cs.drexel.edu/~bls96/museum/cardiac.html

 - https://en.wikipedia.org/wiki/Signedness

#+begin_quote
In computing, signedness is a property of data types representing numbers in computer programs.

A numeric variable is *signed*:
 - if it can represent both *positive and negative* numbers,

And *unsigned*:
 - if it can only represent non-negative numbers (*zero or positive numbers*).
#+end_quote   

 
** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bits-bytes-words-and-number-bases][Bits, Bytes, Words, and Number Bases]]

 | Bit | Byte                     | Word                         | Number Base       |
 |-----+--------------------------+------------------------------+-------------------|
 | 0/1 | 8bits                    | 2 bytes grouped (16 bits)    | binary            |
 |     | 76543210                 | 5432109876543210             | base 2            |
 |     | unsigned value 0-255     | bit 15 "High order sign bit" | add a lead 0      |
 |     | signed value of -128/127 |                              | and terminating b |
 |     | Bit 7 the "sign bit":    |                              | 011111111b        |
 |     | - 1: negative            |                              | ----------------- |
 |     | - 2: positve             |                              | hexadecimal       |
 |     |                          |                              | nybble:           |
 |     |                          |                              | - 4 bits (0-15)   |
 |     |                          |                              |                   |


unsigned value ranges for common word sizes

#+begin_quote
1 bit:  0-1
2 bits: 0-3
3 bits: 0-7
4 bits: 0-15
5 bits, 0-31
...
#+end_quote

The pattern here is that the max value is 2 to the number of bits minus 1.
That is for 5 bits, the max value 31 is 2 to the 5th power (32) minus 1.

When we convert a binary byte to hex, we visualize it something like this:

#+begin_quote
76543210 is 7654 3210
#+end_quote

We've grouped the bits as two nybbles.
We can then convert the two nybbles (4 bits each) to two hex digits.

| Binary | Hex | Dec |
|--------+-----+-----|
|   0000 |   0 |   0 |
|   0001 |   1 |   1 |
|   0010 |   2 |   2 |
|   0011 |   3 |   3 |
|   0100 |   4 |   4 |
|   0101 |   5 |   5 |
|   0110 |   6 |   6 |
|   0111 |   7 |   7 |
|   1000 |   8 |   8 |
|   1001 |   9 |   9 |
|   1010 |   A |  10 |
|   1011 |   B |  11 |
|   1100 |   C |  12 |
|   1101 |   D |  13 |
|   1110 |   E |  14 |
|   1111 |   F |  15 |


For example, we visualize the binary value 010100101b as 1010 0101.
Using the table above, we see 1010 is A, and 0101 is 5. So the byte value is A5.
We represent hex numbers in assembly as 0xa5, or 0a5h, or sometimes $a5.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#math][Math]]

Adding two values of the same word size:
 The byte 100 plus the byte 50 = 150. 100 + 50 = 150.

This works for signed and unsigned values.
The math is always unsigned, but the result is up to you.
If the high order bit (bit 7 of a byte, bit 15 of a 16-bit word...) is 1, the signed value is negative.

What happens when we add a byte value to a 16-bit word value?
 - The byte value is really a 16-bit value, but the upper 8 bits are zeros.
 - That is, 0xaa can be visualized as 0x00aa. We just add the full 16-bit values together.

What happens when we add 1 to a byte size value of 255?
We only have 8 bits for the result, but we have 9 bits of actual value.
That is, 255 + 1 is 256.
Represented in binary, you have 255 = 011111111b + 1 = 0100000000b (9 bits!).
The 9th bit is basically ignored as far as the result byte goes.
So if you look at the lower 8 bits of our 9 bit result, we get 0!

All this extends to 32 bit and 64 bit words.

Multiplication of two values requires a double-sized result,
or you lose a lot more than just the 9th bit.

Consider 255 x 255 = 65025 (0xfe01), which fits in 16 bits but not in 8.
If we have a byte result, we get 0x01 due to the overflow, losing over 65000 in result value.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#boolean-algebra][Boolean Algebra]]

Single value operands, 4 combinations possible (truth table):

#+begin_src
AND (if both operands are true, the result is true)
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

OR (if either operand is true, the result is true)
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

XOR (if only one operand is true, the result is true)
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
#+end_src

The ~ (1's complement) operator inverts the bits in the word.

#+begin_src asm
00000000 & 00000000 = 0
00000000 & 00000001 = 0
...
#+end_src

BUT, we have 8 bits, so the operation is performed on all 8 bits in the two operands.

#+begin_src asm
   10000000 
OR 00000001 
   --------
   ^      ^
=  10000001
   ^      ^
   
NOT 10000001
=   01111110
#+end_src

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bit-shifting][Bit Shifting]]

shift a bit to the left (<< operator in C) 1-7 bits:

#+begin_src asm 
001111101b << 1 = 011111010b

 001111101b  shifted left becomes
 ////////
x011111010b  (bit 0 becomes 0, bit 1 becomes 1, bit 2 becomes 0)
#+end_src

Note that we have the overflow problem here, as we did with addition. We have an upper bit that ends up in the "bit bucket" (thrown away).

A *left shift* of *1 bit is effectively a multiplication by 2*.
Consider 001b<<1 is 010b, or 2.
A left shift of *2 bits is a multiply by 4*, and so on.

 - left shift of n bits:

| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | Dec |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |    |   | 0 | 1 | 0 |   2 |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |    |   | 1 | 0 | 0 |   4 |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |    | 1 | 0 | 0 | 0 |   8 |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |  1 | 0 | 0 | 0 | 0 |  16 |

Shifting to the right , but we now end up with the high bit being cleared and the low bit in the bit bucket.
A *right shift* of *1 bit is effectively a divide by 2*.
But this right shift will take a *negative number and make it positive* because the *sign bit is cleared*. 

So we need a second kind of right shift (*arithmetic shift right*)
for signed values that sets the high bit in the result to the high bit in the initial value.

A *rotation left/right* is the same as a shift,
except instead of the lost bit ending up in the bit bucket, it becomes the new high/low bit.

Other than for the multiply and divide effects, we use bit shifting frequently with Boolean Algebra.

#+begin_src 
To set bit 3:
n | (1<<3) 

To clear bit 3:

n & ~(1<<3)

Note that
  1<<3  =   01000b,
~(1<<3) is ~01000b,
        or  00111b, (all the bits are inverted)
When you and with 00111b, you are clearing bit 3
#+end_src


 - [[https://en.wikibooks.org/wiki/C_Programming/stdint.h#Exact-width_integer_types][Exact width integer types]]
 
| Specifier | Signing  | Bits | Bytes | Minimum Value | Maximum Value |
|-----------+----------+------+-------+---------------+---------------|
| int8_t    | Signed   |    8 |     1 | −2^{7}        | 2^{7}         |
| uint8_t   | Unsigned |    8 |     1 | 0             | 2^{8}         |
| int16_t   | Signed   |   16 |     2 | −2^{15}       | 2^{15}        |
| uint16_t  | Unsigned |   16 |     2 | 0             | 2^{16}        |
| int32_t   | Signed   |   32 |     4 | −2^{31}       | 2^{31}        |
| uint32_t  | Unsigned |   32 |     4 | 0             | 2^{32}        |
| int64_t   | Signed   |   64 |     8 | −2^{63}       | 2^{63}        |
| uint64_t  | Unsigned |   64 |     8 | 0             | 2^{64}        |


Set bit, chatGPT example: 

#+begin_src C :exports both  :results output 
#include <stdio.h>
#include <stdint.h>

uint16_t int_to_bin(uint16_t  k); 

int main(void) {
    uint16_t n = 9; 
    printf("before setting the bit 3: %u  ->   %u \n", n, int_to_bin(n));
    n = n | (1 << 3); // set bit 3 (from  0)
    printf("after setting the  bit 3: %u ->  %u \n", n, int_to_bin(n));
    return 0;
}

uint16_t int_to_bin(uint16_t  k) { 
  return ( k==0 || k == 1 ? k : ((k%2)+10*int_to_bin(k/2)));
}

#+end_src

#+RESULTS:
: before setting the bit 3: 9  ->   1001 
: after setting the  bit 3: 9 ->  1001 

#+begin_src 
OR (if either operand is true, the result is true)
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

n | (1<<3) 

  00000101  (n = 5)
| 00001000  (1 << 3 = 8)
------------
  00001101  (resultado = 13)
#+end_src

|   7 |  6 |  5 |  4 | *3* | 2 | 1 | 0 | Dec |
| 128 | 64 | 32 | 16 |   8 | 4 | 2 | 1 |     |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |     | 1 | 0 | 1 |   5 |
|     |    |    |    |   1 | 1 | 0 | 1 |  13 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |     | 1 | 1 | 0 |   6 |
|     |    |    |    |   1 | 1 | 1 | 0 |  14 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |     | 1 | 1 | 1 |   7 |
|     |    |    |    |   1 | 1 | 1 | 1 |  15 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |   1 | 0 | 0 | 0 |   8 |
|     |    |    |    |   1 | 0 | 0 | 0 |   8 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |   1 | 0 | 0 | 1 |   9 |
|     |    |    |    |   1 | 0 | 0 | 1 |   9 |









* ray nasmtutorial

https://cs.lmu.edu/~ray/notes/nasmtutorial/

#+begin_src asm  
	global _start

	section .text
_start: mov     rax, 1       ; sys call for write
	mov     rdi, 1       ; file handle 1 is stdout
	mov     rsi, message ; address of string to output
	mov     rdx, 13      ; number of bytes
	syscall              ; invoke os to d the write
        mov     rax, 60      ; sys call for exit
	xor     rdi, rdi     ; exit code 0
        syscall
	section .data
 message: db    "Hello, world", 10 ; note the newline at the end
#+end_src

A typical use of the AND operator is to clear bits in a value. If we AND with a value that is the inverse of a power of 2, we are simply clearing a bit. n AND !4 clears bit 3 in n.



#+begin_src sh  :eval no 
nasm -fmacho64 hello.asm && ld hello.o && ./a.out
#+end_src







* GDB

https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_54.html

#+begin_src 
Output formats
By default, GDB prints a value according to its data type. Sometimes this is not what you want.
For example, you might want to print a number in hex, or a pointer in decimal.
Or you might want to view data in memory at a certain address as a character string or as an instruction.
To do these things, specify an output format when you print a value.

The simplest use of output formats is to say how to print a value already computed.
This is done by starting the arguments of the print command with a slash and a format letter.
The format letters supported are:

x
Regard the bits of the value as an integer, and print the integer in hexadecimal.

d
Print as integer in signed decimal.

u
Print as integer in unsigned decimal.

o
Print as integer in octal.

t
Print as integer in binary. The letter `t' stands for "two". (2)

a
Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol.
You can use this format used to discover where (in what function) an unknown address is located:
(gdb) p/a 0x54320
$3 = 0x54320 <_initialize_vx+396>
The command info symbol 0x54320 yields similar results. See section Examining the Symbol Table.

c
Regard as an integer and print it as a character constant.

f
Regard the bits of the value as a floating point number and print using typical floating point syntax.
For example, to print the program counter in hex (see section Registers), type

p/x $pc

Note that no space is required before the slash; this is because command names in GDB cannot contain a slash.
To reprint the last value in the value history with a different format,
you can use the print command with just a format and no expression.

For example, `p/x' reprints the last value in hex.
#+end_src
