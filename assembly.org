#+OPTIONS: author:nil date:nil toc:nil  html-postamble:nil 
#+LATEX_HEADER: \usepackage[left=2cm, right=2cm, top=1.5cm, bottom=2cm]{geometry}
#+LATEX_HEADER: \usepackage[scaled]{helvet} \renewcommand\familydefault{\sfdefault}
#+LATEX_HEADER: \usepackage{anyfontsize}
#+LATEX_HEADER: \AtBeginDocument{\fontsize{14}{14}\selectfont}

* Resources

 - https://www.youtube.com/watch?v=GhTAoilsFUs
 - https://learnopengl.com/
 - https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/
 - https://www.nasm.us/doc/
 - https://pacman128.github.io/pcasm/
 - https://cs.lmu.edu/~ray/notes/nasmtutorial/
 - https://www.codecademy.com/learn/computer-architecture-assembly-language
 - https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/resources/intro-to-assembly-language-8-13-/
 - https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file (zerg)
 - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

 
* General 

 - X86 registers

| 64-bit | 32-bit | 16-bit | 8 high bits | 8 low bits | Description        |
|--------+--------+--------+-------------+------------+--------------------|
| RAX    | EAX    | AX     | AH          | AL         | Accumulator        |
| RBX    | EBX    | BX     | BH          | BL         | Base               |
| RCX    | ECX    | CX     | CH          | CL         | Counter            |
| RDX    | EDX    | DX     | DH          | DL         | Data               |
| RSI    | ESI    | SI     | N/A         | SIL        | Source             |
| RDI    | EDI    | DI     | N/A         | DIL        | Destination        |
| RSP    | ESP    | SP     | N/A         | SPL        | Stack Pointer      |
| RBP    | EBP    | BP     | N/A         | BPL        | Stack Base Pointer |


* https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file

 - https://www.cs.drexel.edu/~bls96/museum/cardiac.html

 - https://en.wikipedia.org/wiki/Signedness

#+begin_quote
In computing, signedness is a property of data types representing numbers in computer programs.

A numeric variable is *signed*:
 - if it can represent both *positive and negative* numbers,

And *unsigned*:
 - if it can only represent non-negative numbers (*zero or positive numbers*).
#+end_quote   

 
** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bits-bytes-words-and-number-bases][Bits, Bytes, Words, and Number Bases]]

 | Bit | Byte                     | Word                         | Number Base       |
 |-----+--------------------------+------------------------------+-------------------|
 | 0/1 | 8bits                    | 2 bytes grouped (16 bits)    | binary            |
 |     | 76543210                 | 5432109876543210             | base 2            |
 |     | unsigned value 0-255     | bit 15 "High order sign bit" | add a lead 0      |
 |     | signed value of -128/127 |                              | and terminating b |
 |     | Bit 7 the "sign bit":    |                              | 011111111b        |
 |     | - 1: negative            |                              | ----------------- |
 |     | - 2: positve             |                              | hexadecimal       |
 |     |                          |                              | nybble:           |
 |     |                          |                              | - 4 bits (0-15)   |
 |     |                          |                              |                   |


unsigned value ranges for common word sizes

#+begin_quote
1 bit:  0-1
2 bits: 0-3
3 bits: 0-7
4 bits: 0-15
5 bits, 0-31
...
#+end_quote

The pattern here is that the max value is 2 to the number of bits minus 1.
That is for 5 bits, the max value 31 is 2 to the 5th power (32) minus 1.

When we convert a binary byte to hex, we visualize it something like this:

#+begin_quote
76543210 is 7654 3210
#+end_quote

We've grouped the bits as two nybbles.
We can then convert the two nybbles (4 bits each) to two hex digits.

| Binary | Hex | Dec |
|--------+-----+-----|
|   0000 |   0 |   0 |
|   0001 |   1 |   1 |
|   0010 |   2 |   2 |
|   0011 |   3 |   3 |
|   0100 |   4 |   4 |
|   0101 |   5 |   5 |
|   0110 |   6 |   6 |
|   0111 |   7 |   7 |
|   1000 |   8 |   8 |
|   1001 |   9 |   9 |
|   1010 |   A |  10 |
|   1011 |   B |  11 |
|   1100 |   C |  12 |
|   1101 |   D |  13 |
|   1110 |   E |  14 |
|   1111 |   F |  15 |


For example, we visualize the binary value 010100101b as 1010 0101.
Using the table above, we see 1010 is A, and 0101 is 5. So the byte value is A5.
We represent hex numbers in assembly as 0xa5, or 0a5h, or sometimes $a5.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#math][Math]]

Adding two values of the same word size:
 The byte 100 plus the byte 50 = 150. 100 + 50 = 150.

This works for signed and unsigned values.
The math is always unsigned, but the result is up to you.
If the high order bit (bit 7 of a byte, bit 15 of a 16-bit word...) is 1, the signed value is negative.

What happens when we add a byte value to a 16-bit word value?
 - The byte value is really a 16-bit value, but the upper 8 bits are zeros.
 - That is, 0xaa can be visualized as 0x00aa. We just add the full 16-bit values together.

What happens when we add 1 to a byte size value of 255?
We only have 8 bits for the result, but we have 9 bits of actual value.
That is, 255 + 1 is 256.
Represented in binary, you have 255 = 011111111b + 1 = 0100000000b (9 bits!).
The 9th bit is basically ignored as far as the result byte goes.
So if you look at the lower 8 bits of our 9 bit result, we get 0!

All this extends to 32 bit and 64 bit words.

Multiplication of two values requires a double-sized result,
or you lose a lot more than just the 9th bit.

Consider 255 x 255 = 65025 (0xfe01), which fits in 16 bits but not in 8.
If we have a byte result, we get 0x01 due to the overflow, losing over 65000 in result value.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#boolean-algebra][Boolean Algebra]]

Single value operands, 4 combinations possible (truth table):

#+begin_src
AND (if both operands are true, the result is true)
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

OR (if either operand is true, the result is true)
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

XOR (if only one operand is true, the result is true)
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
#+end_src

The ~ (1's complement) operator inverts the bits in the word.

#+begin_src asm
00000000 & 00000000 = 0
00000000 & 00000001 = 0
...
#+end_src

BUT, we have 8 bits, so the operation is performed on all 8 bits in the two operands.

#+begin_src asm
   10000000 
OR 00000001 
   --------
   ^      ^
=  10000001
   ^      ^
   
NOT 10000001
=   01111110
#+end_src

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bit-shifting][Bit Shifting]]

shift a bit to the left (<< operator in C) 1-7 bits:

#+begin_src asm 
001111101b << 1 = 011111010b

 001111101b  shifted left becomes
 ////////
x011111010b  (bit 0 becomes 0, bit 1 becomes 1, bit 2 becomes 0)
#+end_src

Note that we have the overflow problem here, as we did with addition. We have an upper bit that ends up in the "bit bucket" (thrown away).

A *left shift* of *1 bit is effectively a multiplication by 2*.
Consider 001b<<1 is 010b, or 2.
A left shift of *2 bits is a multiply by 4*, and so on.

 - left shift of n bits:

| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | Dec |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |    |   | 0 | 1 | 0 |   2 |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |    |   | 1 | 0 | 0 |   4 |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |    | 1 | 0 | 0 | 0 |   8 |
|-----+----+----+----+---+---+---+---+-----|
|     |    |    |    |   | 0 | 0 | 1 |   1 |
|     |    |    |  1 | 0 | 0 | 0 | 0 |  16 |


Shifting to the right , but we now end up with the high bit being cleared and the low bit in the bit bucket.
A *right shift* of *1 bit is effectively a divide by 2*.
But this right shift will take a *negative number and make it positive* because the *sign bit is cleared*. 

So we need a second kind of right shift (*arithmetic shift right*)
for signed values that sets the high bit in the result to the high bit in the initial value.

A *rotation left/right* is the same as a shift,
except instead of the lost bit ending up in the bit bucket, it becomes the new high/low bit.

Other than for the multiply and divide effects, we use bit shifting frequently with Boolean Algebra.

#+begin_src 
To set bit 3:
n | (1<<3) 

To clear bit 3:

n & ~(1<<3)

Note that
  1<<3  =   01000b,
~(1<<3) is ~01000b,
        or  00111b, (all the bits are inverted)
When you and with 00111b, you are clearing bit 3
#+end_src


 - [[https://en.wikibooks.org/wiki/C_Programming/stdint.h#Exact-width_integer_types][Exact width integer types]]
 
| Specifier | Signing  | Bits | Bytes | Minimum Value | Maximum Value |
|-----------+----------+------+-------+---------------+---------------|
| int8_t    | Signed   |    8 |     1 | −2^{7}        | 2^{7}         |
| uint8_t   | Unsigned |    8 |     1 | 0             | 2^{8}         |
| int16_t   | Signed   |   16 |     2 | −2^{15}       | 2^{15}        |
| uint16_t  | Unsigned |   16 |     2 | 0             | 2^{16}        |
| int32_t   | Signed   |   32 |     4 | −2^{31}       | 2^{31}        |
| uint32_t  | Unsigned |   32 |     4 | 0             | 2^{32}        |
| int64_t   | Signed   |   64 |     8 | −2^{63}       | 2^{63}        |
| uint64_t  | Unsigned |   64 |     8 | 0             | 2^{64}        |


Set bit, chatGPT example: 

#+begin_src C :exports both  :results output 
#include <stdio.h>
#include <stdint.h>

uint16_t int_to_bin(uint16_t  k); 

int main(void) {
    uint16_t n = 9; 
    printf("before setting the bit 3: %u  ->   %u \n", n, int_to_bin(n));
    n = n | (1 << 3); // set bit 3 (from  0)
    printf("after setting the  bit 3: %u ->  %u \n", n, int_to_bin(n));
    return 0;
}

uint16_t int_to_bin(uint16_t  k) { 
  return ( k==0 || k == 1 ? k : ((k%2)+10*int_to_bin(k/2)));
}

#+end_src

#+RESULTS:
: before setting the bit 3: 9  ->   1001 
: after setting the  bit 3: 9 ->  1001 

#+begin_src 
OR (if either operand is true, the result is true)
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

n | (1<<3) 

  00000101  (n = 5)
| 00001000  (1 << 3 = 8)
------------
  00001101  (resultado = 13)
#+end_src

|   7 |  6 |  5 |  4 | *3* | 2 | 1 | 0 | Dec |
| 128 | 64 | 32 | 16 |   8 | 4 | 2 | 1 |     |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |     | 1 | 0 | 1 |   5 |
|     |    |    |    |   1 | 1 | 0 | 1 |  13 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |     | 1 | 1 | 0 |   6 |
|     |    |    |    |   1 | 1 | 1 | 0 |  14 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |     | 1 | 1 | 1 |   7 |
|     |    |    |    |   1 | 1 | 1 | 1 |  15 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |   1 | 0 | 0 | 0 |   8 |
|     |    |    |    |   1 | 0 | 0 | 0 |   8 |
|-----+----+----+----+-----+---+---+---+-----|
|     |    |    |    |   1 | 0 | 0 | 1 |   9 |
|     |    |    |    |   1 | 0 | 0 | 1 |   9 |

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#memory][Memory]]

Memory (RAM) can be viewed as an array of bytes.
If you have 1MB of RAM, your array is indexed from 0 to 1MB-1.

In a simple CPU and RAM setup, you might have your program:
  - start at index 0
  - your variables start at the end of the program
  - your heap starts at the end of your variables
  - your stack starts at the top of memory and works its way downward as you push onto it.


#+begin_src 
 Memory
  - program   stack 
  - program's heap  (memory allocation) 
  - store variables

HIGH memory address
   +--------------+
   |              |
   | stack        |
   | grows down   |
   | address 1M   |
   |              |
   +--------------+
   |              |
   | heap         |
   | grows up     |
   |              |
   +--------------+
   |              |
   | uninitalized |
   | global       |
   | variables    |
   |              |
   +--------------+
   |              |
   | initalized   |
   | global       |
   | variables    |
   |              |
   +--------------+
   |              |
   | code         |
   | address 0    |
   |              |
   +--------------+
LOW memory address


  
#+end_src

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#elf-files-and-the-loader][ELF files and the loader]]


The compiler/assembler/linker generate ELF formatted files.

An ELF file is divided into various sections.
The more common sections are:
 - .text (code)
 - .data [initialized data]
 - .rodata read only data (constants)
 - .bss (uninitialized data)
 - and assorted debugging info sections

 1. The operating system program loader reads in the ELF file and allocates memory for the .text section and loads that data from the file into that memory.

 2. Then the loader allocates memory for the initialized data (.data) and reads that data from the file into that memory.

 3. Then the loader allocates memory for the constant data (.rodata) and reads that data from the file into that memory.

 4. The loader allocates memory for the .bss section.
    Since the .bss section is uninitialized, it only needs to be allocated.

 5. The linker reads in intermediate object files (.o) and

 6. links them together to make the final executable.

 7. Each .o file may declare variables that might be accessed from other .o files and
    to access variables that are defined in some other .o file.

 8. The linker fixes up the addresses in the final output so the code works as expected!

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#permissions-sections-and-privileged-instructions][Permissions (Sections and Privileged instructions)]]

| Section | Permissions |
|---------+-------------|
| .data   | read/write  |
| .bss    | read/write  |
| .rodata | read only   |

The way words of the different sizes are stored in memory is determined by the "endianess" of the CPU.

 - Big Endian:
      stores the high byte  first in memory
 - Little Endian:
      stores low byte first 


 - Bit numbering ( [[https://en.wikipedia.org/wiki/Bit_numbering][reference: bit numbering, wikipedia]] ) 

 
| 150 dec     | MSb |   |   |   |   |   |   | LSb |
|-------------+-----+---+---+---+---+---+---+-----|
| Bit Content |   1 | 0 | 0 | 1 | 0 | 1 | 1 |   0 |

The *least significant bit* (LSb):
  Is the bit position in a binary integer representing the binary 1s place of the integer.
  AKA low-order bit or right-most bit.

The *most significant bit* (MSb):
 Represents the highest-order place of the vinary integer.
 AKA high-order bit or left-most bit.

Unsigned integer example:\\ 
 - Value: 149
 - Position of unit value (decimal 1 or 0) is bit position 0 (n=0)

| 149 LSb0    | MSb |    |    |    |   |   |   | LSb |
|-------------+-----+----+----+----+---+---+---+-----|
| bit weight  | 128 | 64 | 32 | 16 | 8 | 4 | 2 |   1 |
| bit content |   1 |  0 |  0 |  1 | 0 | 1 | 0 |   1 |


Signed integer example:\\ 
 - Value: 8 bit signed decimal  
 - Two's complement method
 - MSb: negative weight in signed integers (-128), the other bits have positive weights
 - LSb: has weight 
 - Signed value: -128+2 = -126

| -126 LSb0   |  MSb |    |    |    |   |   |   | LSb |
|-------------+------+----+----+----+---+---+---+-----|
| bit weight  | -128 | 64 | 32 | 16 | 8 | 4 | 2 |   1 |
| bit content |    1 |  0 |  0 |  0 | 0 | 0 | 1 |   0 |


 - Endiannes  ( [[https://en.wikipedia.org/wiki/Endianness][reference: endiannes, wikipedia]] ) :

[[file:./img/32bit-Endianess.svg.png]]

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#mmu][MMU]]

In modern operating systems, the CPU uses an MMU (*Memory Management Unit*) to assign a subset of the system's memory to each program that you run. 

The MMU maps an address in physical memory to a logical address that the program sees and uses.

When a program is launched:

 - it is allocated a small amount of RAM
   - enough for the program's:
      - code 
      - variables 
      - stack
      - and a minimal heap

As the program needs more stack or more heap, the OS adds physical memory to the program's address space using the MMU. The program grows on demand.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#paging-and-swapping][Paging And Swapping]]

Memory is allocated for the MMU in 4096 byte chunks (pages);
this is required by the MMU implementation (hardware).

When your program tries to access an address in memory that isn't mapped by the OS using the MMU,
a *page fault exception* is raised. The OS sees this and might map in an additional page so that the access can succeed.

Out Of Memory:
 - compress programs and/or their data
 - "page" one or more 4096 byte pages from memory to the system's swap file/partition
 - swap out entire programs (and their data) to the swap file/partition.
   - When those programs get to run, they have to be entirely read back into memory (and MMU set up), and perhaps swapping another program to disk

The stack grows down from high memory.
If the stack overflows (grows below the memory allocated for it),
a page fault occurs and the OS can add additional pages to the memory map so the stack has more room.

The heap initially has a small but reasonable amount of RAM allocated.
It can be expanded using the sbrk syscall.
This is what the malloc() function does in C, though the sbrk() function can be called directly if you know what you're doing.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#other-exceptions][Other Exceptions]]

 - Segfault

Access some address that is truly outside the bounds of the program's memory map.
Paging or swapping is not performed in this case.The CPU/MMU raises a segfault exception.

 - Invalid Opcode

Execute instructions that are not valid x64/amd64 instructions.
Example: push a random number on the stack and then return, Your program starts executing at that random address and who knows what data are there? 

 - General Protection

Attempts to execute a privileged instruction

 


* ray nasmtutorial

https://cs.lmu.edu/~ray/notes/nasmtutorial/

#+begin_src asm  
	global _start

	section .text
_start: mov     rax, 1       ; sys call for write
	mov     rdi, 1       ; file handle 1 is stdout
	mov     rsi, message ; address of string to output
	mov     rdx, 13      ; number of bytes
	syscall              ; invoke os to d the write
        mov     rax, 60      ; sys call for exit
	xor     rdi, rdi     ; exit code 0
        syscall
	section .data
 message: db    "Hello, world", 10 ; note the newline at the end
#+end_src

A typical use of the AND operator is to clear bits in a value. If we AND with a value that is the inverse of a power of 2, we are simply clearing a bit. n AND !4 clears bit 3 in n.



#+begin_src sh  :eval no 
nasm -fmacho64 hello.asm && ld hello.o && ./a.out
#+end_src







* GDB

https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_54.html

#+begin_src 
Output formats
By default, GDB prints a value according to its data type. Sometimes this is not what you want.
For example, you might want to print a number in hex, or a pointer in decimal.
Or you might want to view data in memory at a certain address as a character string or as an instruction.
To do these things, specify an output format when you print a value.

The simplest use of output formats is to say how to print a value already computed.
This is done by starting the arguments of the print command with a slash and a format letter.
The format letters supported are:

x
Regard the bits of the value as an integer, and print the integer in hexadecimal.

d
Print as integer in signed decimal.

u
Print as integer in unsigned decimal.

o
Print as integer in octal.

t
Print as integer in binary. The letter `t' stands for "two". (2)

a
Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol.
You can use this format used to discover where (in what function) an unknown address is located:
(gdb) p/a 0x54320
$3 = 0x54320 <_initialize_vx+396>
The command info symbol 0x54320 yields similar results. See section Examining the Symbol Table.

c
Regard as an integer and print it as a character constant.

f
Regard the bits of the value as a floating point number and print using typical floating point syntax.
For example, to print the program counter in hex (see section Registers), type

p/x $pc

Note that no space is required before the slash; this is because command names in GDB cannot contain a slash.
To reprint the last value in the value history with a different format,
you can use the print command with just a format and no expression.

For example, `p/x' reprints the last value in hex.
#+end_src
