

* Resources

 - https://www.nasm.us/doc/
 - https://pacman128.github.io/pcasm/
 - https://cs.lmu.edu/~ray/notes/nasmtutorial/
 - https://www.codecademy.com/learn/computer-architecture-assembly-language
 - https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/resources/intro-to-assembly-language-8-13-/
 - https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file (zerg)
 - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

 
* General 

 - X86 registers

| 64-bit | 32-bit | 16-bit | 8 high bits | 8 low bits | Description        |
|--------+--------+--------+-------------+------------+--------------------|
| RAX    | EAX    | AX     | AH          | AL         | Accumulator        |
| RBX    | EBX    | BX     | BH          | BL         | Base               |
| RCX    | ECX    | CX     | CH          | CL         | Counter            |
| RDX    | EDX    | DX     | DH          | DL         | Data               |
| RSI    | ESI    | SI     | N/A         | SIL        | Source             |
| RDI    | EDI    | DI     | N/A         | DIL        | Destination        |
| RSP    | ESP    | SP     | N/A         | SPL        | Stack Pointer      |
| RBP    | EBP    | BP     | N/A         | BPL        | Stack Base Pointer |


* https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file

 - https://www.cs.drexel.edu/~bls96/museum/cardiac.html

 - https://en.wikipedia.org/wiki/Signedness

#+begin_quote
In computing, signedness is a property of data types representing numbers in computer programs.

A numeric variable is *signed*:
 - if it can represent both *positive and negative* numbers,

And *unsigned*:
 - if it can only represent non-negative numbers (*zero or positive numbers*).
#+end_quote   

 
** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#bits-bytes-words-and-number-bases][Bits, Bytes, Words, and Number Bases]]

 | Bit | Byte                     | Word                         | Number Base       |
 |-----+--------------------------+------------------------------+-------------------|
 | 0/1 | 8bits                    | 2 bytes grouped (16 bits)    | binary            |
 |     | 76543210                 | 5432109876543210             | base 2            |
 |     | unsigned value 0-255     | bit 15 "High order sign bit" | add a lead 0      |
 |     | signed value of -128/127 |                              | and terminating b |
 |     | Bit 7 the "sign bit":    |                              | 011111111b        |
 |     | - 1: negative            |                              | ----------------- |
 |     | - 2: positve             |                              | hexadecimal       |
 |     |                          |                              | nybble:           |
 |     |                          |                              | - 4 bits (0-15)   |
 |     |                          |                              |                   |


unsigned value ranges for common word sizes

#+begin_quote
1 bit:  0-1
2 bits: 0-3
3 bits: 0-7
4 bits: 0-15
5 bits, 0-31
...
#+end_quote

The pattern here is that the max value is 2 to the number of bits minus 1.
That is for 5 bits, the max value 31 is 2 to the 5th power (32) minus 1.

When we convert a binary byte to hex, we visualize it something like this:

#+begin_quote
76543210 is 7654 3210
#+end_quote

We've grouped the bits as two nybbles.
We can then convert the two nybbles (4 bits each) to two hex digits.

| Binary | Hex |
|--------+-----|
|   0000 |   0 |
|   0001 |   1 |
|   0010 |   2 |
|   0011 |   3 |
|   0100 |   4 |
|   0101 |   5 |
|   0110 |   6 |
|   0111 |   7 |
|   1000 |   8 |
|   1001 |   9 |
|   1010 |   A |
|   1011 |   B |
|   1100 |   C |
|   1101 |   D |
|   1110 |   E |
|   1111 |   F |


For example, we visualize the binary value 010100101b as 1010 0101.
Using the table above, we see 1010 is A, and 0101 is 5. So the byte value is A5.
We represent hex numbers in assembly as 0xa5, or 0a5h, or sometimes $a5.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#math][Math]]

Adding two values of the same word size:
 The byte 100 plus the byte 50 = 150. 100 + 50 = 150.

This works for signed and unsigned values.
The math is always unsigned, but the result is up to you.
If the high order bit (bit 7 of a byte, bit 15 of a 16-bit word...) is 1, the signed value is negative.

What happens when we add a byte value to a 16-bit word value?
 - The byte value is really a 16-bit value, but the upper 8 bits are zeros.
 - That is, 0xaa can be visualized as 0x00aa. We just add the full 16-bit values together.

What happens when we add 1 to a byte size value of 255?
We only have 8 bits for the result, but we have 9 bits of actual value.
That is, 255 + 1 is 256.
Represented in binary, you have 255 = 011111111b + 1 = 0100000000b (9 bits!).
The 9th bit is basically ignored as far as the result byte goes.
So if you look at the lower 8 bits of our 9 bit result, we get 0!

All this extends to 32 bit and 64 bit words.

Multiplication of two values requires a double-sized result,
or you lose a lot more than just the 9th bit.

Consider 255 x 255 = 65025 (0xfe01), which fits in 16 bits but not in 8.
If we have a byte result, we get 0x01 due to the overflow, losing over 65000 in result value.

** [[https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file#boolean-algebra][Boolean Algebra]]

Single value operands, 4 combinations possible (truth table):

#+begin_quote
AND (if both operands are true, the result is true)
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

OR (if either operand is true, the result is true)
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

XOR (if only one operand is true, the result is true)
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
#+end_quote



* ray nasmtutorial

https://cs.lmu.edu/~ray/notes/nasmtutorial/

#+begin_src asm  
	global _start

	section .text
_start: mov     rax, 1       ; sys call for write
	mov     rdi, 1       ; file handle 1 is stdout
	mov     rsi, message ; address of string to output
	mov     rdx, 13      ; number of bytes
	syscall              ; invoke os to d the write
        mov     rax, 60      ; sys call for exit
	xor     rdi, rdi     ; exit code 0
        syscall
	section .data
 message: db    "Hello, world", 10 ; note the newline at the end
#+end_src


#+begin_src sh  :eval no 
nasm -fmacho64 hello.asm && ld hello.o && ./a.out
#+end_src







